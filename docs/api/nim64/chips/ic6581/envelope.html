<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>nim64/chips/ic6581/envelope</title>
<link rel="stylesheet" type="text/css" href="../../../nimdoc.out.css">

<script type="text/javascript" src="../../../dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  toggleSwitch.addEventListener('change', switchTheme, false);

  const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null;
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark') {
      toggleSwitch.checked = true;
    }
  }
}
</script>

</head>
<body onload="main()">
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">nim64/chips/ic6581/envelope</h1>
    <div class="row">
  <div class="three columns">
  <div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
      <input type="checkbox" id="checkbox" />
      <div class="slider round"></div>
    </label>
    &nbsp;&nbsp;&nbsp; <em>Dark Mode</em>
  </div>
  <div id="global-links">
    <ul class="simple">
    <li>
      <a href="../../../theindex.html">Index</a>
    </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <div>
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li>
  <a class="reference reference-toplevel" href="#6" id="56">Imports</a>
  <ul class="simple simple-toc-section">
    
  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#7" id="57">Types</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#Envelope"
    title="Envelope = ref object
  envelope_counter: uint ## The envelope counter. The purpose of the envelope generator is
                         ## to calculate this number, which is then readable via the
                         ## `output` proc.
  attack: uint ## The 4-bit attack value. Each value corresponds to an attack of a certain
               ## length, which is derived from the `RateTargets` array above.
  decay: uint ## The 4-bit decay value. Each value corresponds to a decay of a certain
              ## length, assuming a sustain level of `0x00` (the decay will be cut short
              ## if a higher sustain level is reached first). This is given in the
              ## `RateTargets` table, except that exponentiation causes the true decay
              ## value to be three times that listed.
  sustain: uint ## The 4-bit sustain value. This value represents the volume at which
                ## decay will cease  and the note will be held until the `GATE` bit clears
                ## and release begins.
  release: uint ## The 4-bit release value. Each value corresponds to a release of a
                ## certain length, assuming a sustain level of `0xff` (the release will be
                ## shorter with any lower sustain level). This is given in the
                ## `RateTargets` table, except that exponentiation causes the true release
                ## value to be three times that listed.
  gate: bool ## The value of the `GATE` bit of this envelope generator&apos;s `VCREG` register.
             ## When this changes from `false` to `true`, a new attack begins; when it
             ## changes from `true` to `false`, release begins.
  rate_counter: uint ## The internal counter that determines when the envelope counter
                     ## changes. Each time this value reaches its target, the envelope
                     ## counter is increased (on attack) or decreased by `1`.
  falloff_counter: uint ## A separate counter that can cause the envelope counter to take
                        ## 
                        ## multiple rate counter periods before it decrements (between 1
                        ## 
                        ## period and 30). This is used to gradually slow the
                        ## 
                        ## decay/release into a simulated exponential curve.
  rate_target: uint ## The target value for the rate counter to reach before the envelope
                    ## counter can be incremented. This will always be one of the values
                    ## in the `RateTargets` table.
  falloff_target: uint ## The number of rate counter periods that must elapse before the
                       ## envelope counter decrements. This is increased from 1 to 2, 4,
                       ## 8, 16, and finally 30 at certain envelope counter values.
  phase: Phase               ## Tracks the phase of the envelope generator.
  zero_freeze: bool ## Determines whether the envelope counter is capable of changing any
                    ## further. Once the counter reaches `0`, it cannot move until the
                    ## next attack. This is used to skip logic that wouldn&apos;t run anyway
                    ## becuase the envelope counter value is `0` and to implement the
                    ## &quot;bug&quot; that causes the envelope counter to wrap to `0xff` when
                    ## setting `GATE` high and then immediately setting it low.">Envelope</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#12" id="62">Procs</a>
  <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">output
      <li><a class="reference" href="#output%2CEnvelope"
    title="output(env: Envelope): uint">output,<wbr>Envelope</a></li>

  </ul>
  <ul class="simple nested-toc-section">vcreg
      <li><a class="reference" href="#vcreg%2CEnvelope%2Cuint"
    title="vcreg(env: Envelope; value: uint)">vcreg,<wbr>Envelope,<wbr>uint</a></li>

  </ul>
  <ul class="simple nested-toc-section">reset
      <li><a class="reference" href="#reset%2CEnvelope%2Cbool"
    title="reset(env: Envelope; value: bool = true)">reset,<wbr>Envelope,<wbr>bool</a></li>

  </ul>
  <ul class="simple nested-toc-section">new_envelope
      <li><a class="reference" href="#new_envelope"
    title="new_envelope(): Envelope">new_envelope</a></li>

  </ul>
  <ul class="simple nested-toc-section">clock
      <li><a class="reference" href="#clock%2CEnvelope"
    title="clock(env: Envelope)">clock,<wbr>Envelope</a></li>

  </ul>
  <ul class="simple nested-toc-section">surel
      <li><a class="reference" href="#surel%2CEnvelope%2Cuint"
    title="surel(env: Envelope; value: uint)">surel,<wbr>Envelope,<wbr>uint</a></li>

  </ul>
  <ul class="simple nested-toc-section">atdcy
      <li><a class="reference" href="#atdcy%2CEnvelope%2Cuint"
    title="atdcy(env: Envelope; value: uint)">atdcy,<wbr>Envelope,<wbr>uint</a></li>

  </ul>

  </ul>
</li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc"></p>
  <div class="section" id="6">
<h1><a class="toc-backref" href="#6">Imports</a></h1>
<dl class="item">
<a class="reference external" href="../../utils.html">../../utils</a>
</dl></div>
<div class="section" id="7">
<h1><a class="toc-backref" href="#7">Types</a></h1>
<dl class="item">
<a id="Envelope"></a>
<dt><pre><a href="envelope.html#Envelope"><span class="Identifier">Envelope</span></a> <span class="Other">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
  <span class="Identifier">envelope_counter</span><span class="Other">:</span> <span class="Identifier">uint</span> <span class="Comment">## The envelope counter. The purpose of the envelope generator is</span>
                         <span class="Comment">## to calculate this number, which is then readable via the</span>
                         <span class="Comment">## `output` proc.</span>
  <span class="Identifier">attack</span><span class="Other">:</span> <span class="Identifier">uint</span> <span class="Comment">## The 4-bit attack value. Each value corresponds to an attack of a certain</span>
               <span class="Comment">## length, which is derived from the `RateTargets` array above.</span>
  <span class="Identifier">decay</span><span class="Other">:</span> <span class="Identifier">uint</span> <span class="Comment">## The 4-bit decay value. Each value corresponds to a decay of a certain</span>
              <span class="Comment">## length, assuming a sustain level of `0x00` (the decay will be cut short</span>
              <span class="Comment">## if a higher sustain level is reached first). This is given in the</span>
              <span class="Comment">## `RateTargets` table, except that exponentiation causes the true decay</span>
              <span class="Comment">## value to be three times that listed.</span>
  <span class="Identifier">sustain</span><span class="Other">:</span> <span class="Identifier">uint</span> <span class="Comment">## The 4-bit sustain value. This value represents the volume at which</span>
                <span class="Comment">## decay will cease  and the note will be held until the `GATE` bit clears</span>
                <span class="Comment">## and release begins.</span>
  <span class="Identifier">release</span><span class="Other">:</span> <span class="Identifier">uint</span> <span class="Comment">## The 4-bit release value. Each value corresponds to a release of a</span>
                <span class="Comment">## certain length, assuming a sustain level of `0xff` (the release will be</span>
                <span class="Comment">## shorter with any lower sustain level). This is given in the</span>
                <span class="Comment">## `RateTargets` table, except that exponentiation causes the true release</span>
                <span class="Comment">## value to be three times that listed.</span>
  <span class="Identifier">gate</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Comment">## The value of the `GATE` bit of this envelope generator's `VCREG` register.</span>
             <span class="Comment">## When this changes from `false` to `true`, a new attack begins; when it</span>
             <span class="Comment">## changes from `true` to `false`, release begins.</span>
  <span class="Identifier">rate_counter</span><span class="Other">:</span> <span class="Identifier">uint</span> <span class="Comment">## The internal counter that determines when the envelope counter</span>
                     <span class="Comment">## changes. Each time this value reaches its target, the envelope</span>
                     <span class="Comment">## counter is increased (on attack) or decreased by `1`.</span>
  <span class="Identifier">falloff_counter</span><span class="Other">:</span> <span class="Identifier">uint</span> <span class="Comment">## A separate counter that can cause the envelope counter to take</span>
                        <span class="Comment">## </span>
                        <span class="Comment">## multiple rate counter periods before it decrements (between 1</span>
                        <span class="Comment">## </span>
                        <span class="Comment">## period and 30). This is used to gradually slow the</span>
                        <span class="Comment">## </span>
                        <span class="Comment">## decay/release into a simulated exponential curve.</span>
  <span class="Identifier">rate_target</span><span class="Other">:</span> <span class="Identifier">uint</span> <span class="Comment">## The target value for the rate counter to reach before the envelope</span>
                    <span class="Comment">## counter can be incremented. This will always be one of the values</span>
                    <span class="Comment">## in the `RateTargets` table.</span>
  <span class="Identifier">falloff_target</span><span class="Other">:</span> <span class="Identifier">uint</span> <span class="Comment">## The number of rate counter periods that must elapse before the</span>
                       <span class="Comment">## envelope counter decrements. This is increased from 1 to 2, 4,</span>
                       <span class="Comment">## 8, 16, and finally 30 at certain envelope counter values.</span>
  <span class="Identifier">phase</span><span class="Other">:</span> <span class="Identifier">Phase</span>               <span class="Comment">## Tracks the phase of the envelope generator.</span>
  <span class="Identifier">zero_freeze</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Comment">## Determines whether the envelope counter is capable of changing any</span>
                    <span class="Comment">## further. Once the counter reaches `0`, it cannot move until the</span>
                    <span class="Comment">## next attack. This is used to skip logic that wouldn't run anyway</span>
                    <span class="Comment">## becuase the envelope counter value is `0` and to implement the</span>
                    <span class="Comment">## &quot;bug&quot; that causes the envelope counter to wrap to `0xff` when</span>
                    <span class="Comment">## setting `GATE` high and then immediately setting it low.</span>
  </pre></dt>
<dd>

<p>A single envelope generator, one of three that appears on a 6581 SID.</p>
<p>The envelope generator is used to modify the amplitude of the sound that comes from one of the oscillator/waveform generators. It takes the flat, single-amplitude sound that the oscillator generates and adds dynamics depending on parameters in the <tt class="docutils literal"><span class="pre">ATDCY</span></tt> and <tt class="docutils literal"><span class="pre">SUREL</span></tt> registers that are associated with that envelope generator (there are three envelope generators, so there is an <tt class="docutils literal"><span class="pre">ATDCY1</span></tt> register, an <tt class="docutils literal"><span class="pre">ATDCY2</span></tt> register, and so on).</p>
<p>Each envelope generator is in one of four phases: attack, decay, sustain, or release. The attack phase begins when the <tt class="docutils literal"><span class="pre">GATE</span></tt> bit of the <tt class="docutils literal"><span class="pre">VCREG</span></tt> register is set to <tt class="docutils literal"><span class="pre">1</span></tt>. The envelope counter then increases linearly at a rate determined by the value of the high 4 bits of the <tt class="docutils literal"><span class="pre">ATDCY</span></tt> register until it reaches the maximum value of <tt class="docutils literal"><span class="pre">0xff</span></tt>, and that's when the decay phase begins. The envelope counter then decreases, this time at the rate determined by the value of the <em>low</em> four bits of the <tt class="docutils literal"><span class="pre">ATDCY</span></tt> register. When it reaches the level determined by the high 4 bits of the <tt class="docutils literal"><span class="pre">SUREL</span></tt> register, the envelope counter stops decreasing and holds steady (the sustain phase) until the <tt class="docutils literal"><span class="pre">GATE</span></tt> bit of the <tt class="docutils literal"><span class="pre">VCREG</span></tt> register is set to <tt class="docutils literal"><span class="pre">0</span></tt>. At that point the release phase begins, and the envelope counter again descencds (this time at a rate determined by the bottom 4 bits of <tt class="docutils literal"><span class="pre">SUREL</span></tt>) until it reaches <tt class="docutils literal"><span class="pre">0x00</span></tt>.</p>
<p>Unlike in the attack phase, the envelope counter does not change linearly in the decay or release phases. Instead, the rate falls off step by step to simulate a smooth exponential curve.</p>
<p>The actual 6581 uses a pair of shift register/PLA combos to provide the logic to control how quickly the envelope counter is incremented or decremented. While we do actually implement a shift register for oscillator noise production, the shift registers here require neither tapping nor feedback, so they are much more simply implemented as a counter and a set of tables to provide targets.</p>


</dd>

</dl></div>
<div class="section" id="12">
<h1><a class="toc-backref" href="#12">Procs</a></h1>
<dl class="item">
<a id="vcreg,Envelope,uint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#vcreg%2CEnvelope%2Cuint"><span class="Identifier">vcreg</span></a><span class="Other">(</span><span class="Identifier">env</span><span class="Other">:</span> <a href="envelope.html#Envelope"><span class="Identifier">Envelope</span></a><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">uint</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Processes changes to the appropriate <tt class="docutils literal"><span class="pre">VCREG</span></tt> register. The envelope generator is only concerned with the <tt class="docutils literal"><span class="pre">GATE</span></tt> bit of this register; when it is set, the attack/decay/sustain sequence begins, and when it is cleared, the release begins.

</dd>
<a id="atdcy,Envelope,uint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#atdcy%2CEnvelope%2Cuint"><span class="Identifier">atdcy</span></a><span class="Other">(</span><span class="Identifier">env</span><span class="Other">:</span> <a href="envelope.html#Envelope"><span class="Identifier">Envelope</span></a><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">uint</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Processes changes to the appropriate <tt class="docutils literal"><span class="pre">ATDCY</span></tt> register. This sets 4-bit values for attack and decay. If the voice is currently in the phase corresponding to an attack/decay value that has changed, a new rate target will be chosen. This can cause the ADSR delay bug detailed in the <tt class="docutils literal"><span class="pre">clock</span></tt> method below.

</dd>
<a id="surel,Envelope,uint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#surel%2CEnvelope%2Cuint"><span class="Identifier">surel</span></a><span class="Other">(</span><span class="Identifier">env</span><span class="Other">:</span> <a href="envelope.html#Envelope"><span class="Identifier">Envelope</span></a><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">uint</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Processes changes to the appropriate <tt class="docutils literal"><span class="pre">SUREL</span></tt> register. This sets 4-bit values for sustain and release. If the sustain changes to a higher value during sustain itself, then the envelope counter will simply start decrementing again as though back in decay. If the release changes to a value that the rate counter has already passed, then the ADSR delay bug will manifest and the next attack may be delayed.

</dd>
<a id="reset,Envelope,bool"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#reset%2CEnvelope%2Cbool"><span class="Identifier">reset</span></a><span class="Other">(</span><span class="Identifier">env</span><span class="Other">:</span> <a href="envelope.html#Envelope"><span class="Identifier">Envelope</span></a><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">=</span> <span class="Identifier">true</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Resets the envelope generator to its default state. This only does anything when <tt class="docutils literal"><span class="pre">value</span></tt> is true; this represents the level of the <tt class="docutils literal"><span class="pre">RES</span></tt> pin and indicates that the pin has returned to high after being pulled low.

</dd>
<a id="clock,Envelope"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#clock%2CEnvelope"><span class="Identifier">clock</span></a><span class="Other">(</span><span class="Identifier">env</span><span class="Other">:</span> <a href="envelope.html#Envelope"><span class="Identifier">Envelope</span></a><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Called when the SID's clock pin goes high. This manipulates three separate counters that control the envelope generator output.<ol class="simple"><li>The rate counter increments by 1 with every clock. If it has not reached its target (which is determined by the settings in the attack, decay, and release registers), then this method does nothing until called again on the next clock.</li>
<li>Once the rate counter reaches its target, the envelope counter is either incremented (on attack) or decremented (on decay or release). The envelope counter changes counting directions after reaching 0xff on attack (it changes to decay/sustain phase at that point) and stops descending when it reaches the sustain level and, after the release phase is entered, at 0x00.</li>
<li><p>The falloff counter changes at certain breakpoints of the envelope counter as it descends. This counter acts in much the same way as the rate counter; the envelope counter doesn't change until the falloff counter reaches its target. The breakpoints and targets are chosen to make a smooth exponential decay/release curve, which sounds more natural.</p>
<p>This exponential curve also happens to take three times longer to complete than a linear curve; hence all of the SID documentation giving values for decay/release as three times the length of attack.</p>
</li>
</ol>


</dd>
<a id="output,Envelope"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#output%2CEnvelope"><span class="Identifier">output</span></a><span class="Other">(</span><span class="Identifier">env</span><span class="Other">:</span> <a href="envelope.html#Envelope"><span class="Identifier">Envelope</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Returns the current value of the envelope counter for this clock cycle.

</dd>
<a id="new_envelope"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#new_envelope"><span class="Identifier">new_envelope</span></a><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <a href="envelope.html#Envelope"><span class="Identifier">Envelope</span></a> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Creates a new envelope generator with all internal values set to what they would be after a reset.

</dd>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2021-08-09 13:37:42 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
