## Copyright (c) 2021 Thomas J. Otterson
## 
## This software is released under the MIT License.
## https:#opensource.org/licenses/MIT

## An emulation of the 82S100 Programmable Logic Array, as it was programmed for early
## Commodore 64s.
##
## The 82S100 is a programmable logic chip made by Signetics and is regarded as the very
## first programmable logic device, first released in 1975. It took 16 inputs and could form
## up to 48 product terms (P-terms) by logically ANDind and NOTing selections of the 16
## inputs. These P-terms were then fed to another array that would logically OR them
## selectively, producing up to 8 sum terms (S-terms) that were ultimately sent to the
## output pins (possibly after NOTing them first). The programming for these P- and S-terms
## could be done in the field in a similar manner to that of a PROM (programmable read-only
## memory), and Commodore would program them as a part of production of the C64.
##
## A single 82S100 could therefore serve the same function as a large number of 7400-series
## logic devices, for instance. It was used in a vast array of machines, including other
## Commodore computers and disk drives and those from several other companies. The
## differences between the 82S100's used in each would be the programming of the logic
## arrays.
##
## CBM eventually created their own hard-coded versions of the 82S100, which were faster and
## were cheaper for CBM to produce than it was for them to buy and program 82S100's. The
## schematic from which this emulation is being produced is an early one, from July, 1982,
## and at that time the C64 was still using the Signetics device.
##
## The input pins of the 82S100 were generically named `I0`-`I15`, and the output pins were
## similarly named `F0`-`F7`. That has been maintained here, though constants are provided
## to be able to use the more C64-centric names that reflect the pins' actual functions in
## that computer.
##
## This chip was tasked with providing the chip enable signals for the C64's RAM and color
## RAM; BASIC, kernal, and character ROM; registers from the 6526 CIAs, 6567 VIC, and 6581
## SID; and two banks of cartridge ROM and two banks of cartridge I/O memory. The 6510
## processor, having a 16-bit address bus, could access 64k of memory, but all of this RAM
## and ROM together added up to closer to 84k. Therefore the PLA used a combination of
## inputs, including some of the address bus, the specialized 6510 I/O port bus, and signals
## from the VIC and cartridge ROMs to determine which memory was trying to be accessed at
## any given time, and then provide chip enable signals for that memory (turning it on and
## turning other memory that could be at the same address off). It would do this for every
## memory access, which would happen twice per cycle (half the cycle was used by the CPU,
## half by the VIC). Thus bank switching actually happened at a frequency of 2MHz, twice the
## CPU clock frequency, and the chip generated a fair bit of heat.
##
## The purpose of the logic in the PLA is to take the current state of the system during a
## memory access and produce a single output enabling the one device (memory chip, processor
## chip with register, cartridge, etc.) that will handle that memory access. (If the
## selected output is `IO`, that indicates that the I/O block of memory is being accessed,
## but the PLA cannot determine *which* device is being accessed from this information
## alone. When that happens, a separate demultiplexer uses A8-A11 to determine which device
## it is.)
##
## ### Input pin assignments
##
## * `I0`: `CAS`. This is the control line from the VIC that enables access to RAM. Instead
##   of going directly to RAM, this line comes to the PLA and if RAM access is selected, the
##   CASRAM output is sent to the RAM chips.
## * `I1`: `LORAM`. This line controls the memory block from `$A000`-`$BFFF`. When high
##   (normal), the BASIC ROM is available in this memory block. When low, it's switched out
##   for RAM.
## * `I2`: `HIRAM`. This line controls the memory area from `$E000`-`$FFFF`. When high
##   (normal), the KERNAL ROM is available in this memory block. When low, it's switched out
##   for RAM.
## * `I3`: `CHAREN`. This line partially controls the memory block from `$D000`-`$DFFF`.
##   When high (normal), the I/O devices appear in this memory block. When low, the
##   character ROM appears here instead. This line can be overridden by other signals,
##   including those allowing this memory block to contain RAM instead.
## * `I4`, `I14`-`I15`: `VA14`, `VA13`, and `VA12`. When the VIC is active, these are used
##   to determine which block of memory the VIC is trying to access. `VA14` is active low
##   because that's the way it's generated by CIA2; it's inverted back into active high
##   before being used to access memory but not for use with the PLA.
## * `I5`-`I8`: `A15`-`A12`. Used to determine which block of memory the CPU wishes to
##   access while the CPU is active.
## * `I9`: `BA`. The VIC sets this "Bus Available" line high to indicate normal bus
##   operation, switching between VIC and CPU each cycle. The VIC sets it low when it
##   intends to take exclusive access of the address bus.
## * `I10`: `AEC`. This inverse of the VIC's "Address Enable Control" signal indicates which
##   of the CPU (low) or VIC (high) is in control of the data bus.
## * `I11`: `R_W`. A high signal means that memory is being read, while a low means memory
##   is being written. This makes a difference to what memory is being accessed. For
##   example, ROM cannot be written; if an attempt is made to write to a ROM address while
##   ROM is banked in, the write will happen to RAM instead.
## * `I12`-`I13`: `GAME` and `EXROM`. These are used by cartridges to indicate the presence
##   of addressable memory within them. There are two for-sure states for these two signals:
##   if both are high (the normal state), there is no cartridge; and if `EXROM` is high and
##   `GAME` is low, there is an Ultimax cartridge. Further mapping to cartridge ROM depends
##   not only on these two signals but also on `LORAM`, `HIRAM`, and `CHAREN` there is a
##   nice table at https:#www.c64-wiki.com/wiki/Bank_Switching#Mode_Table.
##
## ### Output pin assignments
##
## Since the outputs are fed to chip select pins, which are universally active low, all of
## these are programmed to be inverted. Thus, at last seven of them will be high at any
## given time and at most one will be low.
##
## * `F0`: `CASRAM`. This is the signal that ultimately enables RAM. The production of this
##   signal is very different from the others. For all other output, if one of their terms
##   is selected, that output will be selected. For `CASRAM`, its terms are combined with 
##   the terms from all other outputs (except for `GR_W`), and if any of the terms are
##   selected, then `CASRAM` will be *de*selected. (Even if all of those other outputs are
##   deselected, `CASRAM` will be deselected if `CAS` is high or if certain addresses are
##   accessed while an Ultimax cartridge is plugged in. In these cases, no PLA outputs will
##   be selected.)
## * `F1`: `BASIC`. Enables the BASIC ROM.
## * `F2`: `KERNAL`. Enables the KERNAL ROM.
## * `F3`: `CHAROM`. Enables the Character ROM.
## * `F4`: `GR_W`. Indicates that the static color RAM is being written to. Note that this
##   is the only output that is not actually a chip enable signal; color RAM is possibly
##   enabled if the `IO` output is selected (see the Ic74139 for details).
## * `F5`: `IO`. Indicates that one of the following are going to be enabled: CIA1
##   registers, CIA2 registers, VIC registers, SID registers, color RAM, expansion port I/O
##   from address `$DE00`-`$DEFF`, or expansion port I/O from address `$DF00`-`$DFFF`. Which
##   of these is actually enabled is done by decoding `A8`-`A11`, which is done by the
##   74139.
## * `F6`: `ROML`. Enables expansion port ROM from `$8000`-`$9FFF`.
## * `F7`: `ROMH`. Enables expansion port ROM from `$E000`-`$EFFF`.
##
## There is a ton of information about the internal workings of the C64's version of the
## 82S100 in "The C64 PLA Dissected" at
## http:#skoe.de/docs/c64-dissected/pla/c64_pla_dissected_a4ds.pdf. This document was used
## to derive all of the logic in this object and has a number of interesting stories besides
## (if you find that sort of thing interesting).
##
## Additionally, the 82S100 has an active-low chip enable pin `CE` which is not used in the
## Commodore 64 (it is tied directly to ground and therefore is always low, so the chip is
## always enabled). There is also an `FE` pin that was used for programming the chip in the
## field; the emulated chip from the C64 doesn't use this as the chip was programmed during
## manufacturing.
##
## The chip comes in a 28-pin dual in-line package with the following pin assignments.
## ```
##         +-----+--+-----+
##      FE |1    +--+   28| Vcc
##      I7 |2           27| I8
##      I6 |3           26| I9
##      I5 |4           25| I10
##      I4 |5           24| I11
##      I3 |6           23| I12
##      I2 |7           22| I13
##      I1 |8   82S100  21| I14
##      I0 |9           20| I15
##      F7 |10          19| CE
##      F6 |11          18| F0
##      F5 |12          17| F1
##      F4 |13          16| F2
##     Vss |14          15| F3
##         +--------------+
## ```
## The pin assignments are very straightforward and are described here.
##
## =====  ======  ========  ===============================================================
## Pin    Name    C64 Name  Description
## =====  ======  ========  ===============================================================
## 1      FE                Field programming pin.
## 2      I7      A13       Input pin 7, tied to line 13 of the address bus.
## 3      I6      A14       Input pin 6, tied to line 14 of the address bus.
## 4      I5      A15       Input pin 5, tied to line 15 of the address bus.
## 5      I4      VA14      Input pin 4, tied to line 14 of the VIC address bus.
## 6      I3      CHAREN    Input pin 3, tied to the CHAREN signal from the CPU I/O port.
## 7      I2      HIRAM     Input pin 2, tied to the HIRAM signal from the CPU I/O port.
## 8      I1      LORAM     Input pin 1, tied to the LORAM signal from the CPU I/O port.
## 9      I0      CAS       Input pin 0, tied to the CAS signal from the VIC.
## 10     F7      ROMH      Output pin 7, enabling the high bank of cartridge ROM.
## 11     F6      ROML      Output pin 6, enabling the low bank of cartridge ROM.
## 12     F5      IO        Output pin 5, enabling the registers from the other chips.
## 13     F4      GR_W      Output pin 4, controlling the R/W from color RAM.
## 14     GND               Electrical ground, not emulated.
## 15     F3      CHAROM    Output pin 3, enabling the 2332 Character ROM.
## 16     F2      KERNAL    Output pin 2, enabling the 2364 Kernal ROM.
## 17     F1      BASIC     Output pin 1, enabling the 2364 Basic ROM.
## 18     F0      CASRAM    Output pin 0, controlling the CAS inputs of the 4164 DRAMs.
## 19     OE                Output enable, always low (active) in the C64.
## 20     I15     VA12      Input pin 15, tied to line 12 of the VIC address bus.
## 21     I14     VA13      Input pin 14, tied to line 13 of the VIC address bus.
## 22     I13     GAME      Input pin 13, tied to the GAME signal from the cartridge port.
## 23     I12     EXROM     Input pin 12, tied to the EXROM signal from the cartridge port.
## 24     I11     R_W       Input pin 11, tied to the R/W signal from the CPU.
## 25     I10     AEC       Input pin 10, tied to the AEC signal from the VIC.
## 26     I9      BA        Input pin 9, tied to the BA signal from the VIC.
## 27     I8      A12       Input pin 8, tied to line 12 of the address bus.
## 28     VCC               +5V power supply, not emulated.
## 
## It should be noted that among inputs, VA14 and AEC are inverted. VA14 comes that way from
## the CIA, and the regular AEC signal from the VIC is passed through an inverter before it
## reaches the PLA. There are other input signals that are inverted, but these two are the
## ones that might not be expected to be inverted.
##
## In the Commodore 64, U17 is an 82S100. As detailed extensively above, it was used to
## decode signals to determine which chip would receive a particular read or write.

import sequtils
import strformat
import sugar
import ../utils
import ../components/[chip, link]

# We have all of the normal constants for this chip, but they are all given the stock pin
# names (`I0`, `F0`, etc.). So here's another set of constants for the C64-specific names
# for the input and output pins.

const
  CAS*    = 9
  LORAM*  = 8
  HIRAM*  = 7
  CHAREN* = 6
  VA14*   = 5
  A15*    = 4
  A14*    = 3
  A13*    = 2
  A12*    = 27
  BA*     = 26
  AEC*    = 25
  R_W*    = 24
  EXROM*  = 23
  GAME*   = 22
  VA13*   = 21
  VA12*   = 20
  CASRAM* = 18
  BASIC*  = 17
  KERNAL* = 16
  CHAROM* = 15
  GR_W*   = 13
  IO*     = 12
  ROML*   = 11
  ROMH*   = 10

chip Ic82S100:
  pins:
    input:
      # Input pins. In the 82S100, these were generically named I0 through I15, since each
      # pin could serve any function depending on the programming applies.
      I0: 9
      I1: 8
      I2: 7
      I3: 6
      I4: 5
      I5: 4
      I6: 3
      I7: 2
      I8: 27
      I9: 26
      I10: 25
      I11: 24
      I12: 23
      I13: 22
      I14: 21
      I15: 20

      # Output enable, disables all outputs when set high. Tied to ground in the C64, so
      # it's never high.
      OE: 19
    
    output:
      # Output pins. Similar to the input pins, these were named generically on the 82S100.
      F0: 18
      F1: 17
      F2: 16
      F3: 15
      F4: 13
      F5: 12
      F6: 11
      F7: 10
    
    unconnected:
      #  Field programming pin, not used in mask programmed parts and not emulated.
      FE: 1

      # Power supply and ground pins, not emulated.
      VCC: 28
      GND: 14
  
  init:
    proc one_listener(_: Pin) =
      if highp(pins[OE]):
        tri_pins(map(to_seq(0..7), i => pins[&"F{i}"]))
      elif lowp pins[OE]:
        let i0 = highp(pins[I0])
        let i1 = highp(pins[I1])
        let i2 = highp(pins[I2])
        let i3 = highp(pins[I3])
        let i4 = highp(pins[I4])
        let i5 = highp(pins[I5])
        let i6 = highp(pins[I6])
        let i7 = highp(pins[I7])
        let i8 = highp(pins[I8])
        let i9 = highp(pins[I9])
        let i10 = highp(pins[I10])
        let i11 = highp(pins[I11])
        let i12 = highp(pins[I12])
        let i13 = highp(pins[I13])
        let i14 = highp(pins[I14])
        let i15 = highp(pins[I15])

        # These are the product term equations programmed into the PLA for use in a C64. The
        # names for each signal reflect the names of the pins that those signals come from,
        # and while that is an excellent way to make long and complex code succinct, it
        # doesn't do much for the human reader. For that reason, each term has a comment to
        # describe in more human terms what is happening with that piece of the algorithm.
        #
        # Each P-term below has a comment with three lines. The first line describes the
        # state of the three 6510 I/O port lines that are used for bank switching (LORAM,
        # HIRAM, and CHAREN). The second line is the memory address that needs to be
        # accessed to select that P-term (this is from either the regular address bus when
        # the CPU is active or the VIC address bus when the VIC is active). The final line
        # gives information about whether the CPU or the VIC is active, whether the memory
        # access is a read or a write, and what type (if any) of cartridge must be plugged
        # into the expansion port (the cartridge informaion takes into account the values of
        # LORAM, HIRAM, and CHAREN already).
        #
        # If any piece of information is not given, its value doesn't matter to that P-term.
        # For example, in p0, the comment says that LORAM and HIRAM must both be deselected.
        # CHAREN isn't mentioned because whether it is selected or not doesn't change
        # whether that P-term is selected or not.
        #
        # Oftentimes, the reason for multiple terms for one output selection is the
        # limitation on what can be checked in a single logic term, given that no ORs are
        # possible in the production of P-terms. For example, it is very common to see two
        # terms that are identical except that one indicates "no cartridge or 8k cartridge"
        # while the other has "16k cartridge". These two terms together really mean
        # "anything but an Ultimax cartridge", but there's no way to do that in a single
        # term with only AND and NOT.
        #
        # This information comes from the excellent paper available at
        # skoe.de/docs/c64-dissected/pla/c64_pla_dissected_a4ds.pdf. If this sort of thing
        # interests you, there's no better place for information about the C64 PLA.

        # LORAM deselected, HIRAM deselected
        # $A000 - $BFFF
        # CPU active, Read, No cartridge or 8k cartridge
        let p0 = i1 and i2 and i5 and not i6 and i7 and not i10 and i11 and i13

        # HIRAM deselected
        # $E000 - $FFFF
        # CPU active, Read, No cartridge or 8k cartridge
        let p1 = i2 and i5 and i6 and i7 and not i10 and i11 and i13

        # HIRAM deselected
        # $E000 - $FFFF
        # CPU active, Read, 16k cartridge
        let p2 = i2 and i5 and i6 and i7 and not i10 and i11 and not i12 and not i13

        # HIRAM deselected, CHAREN selected
        # $D000 - $DFFF
        # CPU active, Read, No cartridge or 8k cartridge
        let p3 = i2 and not i3 and i5 and i6 and not i7 and i8 and not i10 and i11 and i13

        # LORAM deselected, CHAREN selected
        # $D000 - $DFFF
        # CPU active, Read, No cartridge or 8k cartridge
        let p4 = i1 and not i3 and i5 and i6 and not i7 and i8 and not i10 and i11 and i13

        # HIRAM deselected, CHAREN selected
        # $D000 - $DFFF
        # CPU active, Read, 16k cartridge
        let p5 = i2 and not i3 and i5 and i6 and not i7 and i8 and not i10 and i11 and not i12 and 
          not i13

        #
        # $1000 - $1FFF or $9000 - $9FFF
        # VIC active, No cartridge or 8k cartridge
        let p6 = i4 and not i14 and i15 and i10 and i13

        #
        # $1000 - $1FFF or $9000 - $9FFF
        # VIC active, 16k cartridge
        let p7 = i4 and not i14 and i15 and i10 and not i12 and not i13

        # Unused. May be a relic from earlier design in C64 prototypes that never got removed.
        # let p8 = i0 and i5 and i6 and not i7 and i8 # and not i10 and not i11

        # HIRAM deselected, CHAREN deselected
        # $D000 - $DFFF
        # CPU active, Bus available, Read, No cartridge or 8k cartridge
        let p9 = i2 and i3 and i5 and i6 and not i7 and i8 and not i10 and i9 and i11 and i13

        # HIRAM deselected, CHAREN deselected
        # $D000 - $DFFF
        # CPU active, Write, No cartridge or 8k cartridge
        let p10 = i2 and i3 and i5 and i6 and not i7 and i8 and not i10 and not i11 and i13

        # LORAM deselected, CHAREN deselected
        # $D000 - $DFFF
        # CPU active, Bus available, Read, No cartridge or 8k cartridge
        let p11 = i1 and i3 and i5 and i6 and not i7 and i8 and not i10 and i9 and i11 and i13

        # LORAM deselected, CHAREN deselected
        # $D000 - $DFFF
        # CPU active, Write, No cartridge or 8k cartridge
        let p12 = i1 and i3 and i5 and i6 and not i7 and i8 and not i10 and not i11 and i13

        # HIRAM deselected, CHAREN deselected
        # $D000 - $DFFF
        # CPU active, Bus available, Read, 16k cartridge
        let p13 = i2 and i3 and i5 and i6 and not i7 and i8 and not i10 and i9 and i11 and 
          not i12 and not i13

        # HIRAM deselected, CHAREN deselected
        # $D000 - $DFFF
        # CPU active, Write, 16k cartridge
        let p14 = i2 and i3 and i5 and i6 and not i7 and i8 and not i10 and not i11 and not i12 and 
          not i13

        # LORAM deselected, CHAREN deselected
        # $D000 - $DFFF
        # CPU active, Bus available, Read, 16k cartridge
        let p15 = i1 and i3 and i5 and i6 and not i7 and i8 and not i10 and i9 and i11 and 
          not i12 and not i13

        # LORAM deselected, CHAREN deselected
        # $D000 - $DFFF
        # CPU active, Write, 16k cartridge
        let p16 = i1 and i3 and i5 and i6 and not i7 and i8 and not i10 and not i11 and not i12 and
          not i13

        #
        # $D000 - $DFFF
        # CPU active, Bus available, Read, Ultimax cartridge
        let p17 = i5 and i6 and not i7 and i8 and not i10 and i9 and i11 and i12 and not i13

        #
        # $D000 - $DFFF
        # CPU active, Write, Ultimax cartridge
        let p18 = i5 and i6 and not i7 and i8 and not i10 and not i11 and i12 and not i13

        # LORAM deselected, HIRAM deselected
        # $8000 - $9FFF
        # CPU active, Read, 8k or 16k cartridge
        let p19 = i1 and i2 and i5 and not i6 and not i7 and not i10 and i11 and not i12

        #
        # $8000 - $9FFF
        # CPU active, Ultimax cartridge
        let p20 = i5 and not i6 and not i7 and not i10 and i12 and not i13

        # HIRAM deselected
        # $A000 - $BFFF
        # CPU active, Read, 16k cartridge
        let p21 = i2 and i5 and not i6 and i7 and not i10 and i11 and not i12 and not i13

        #
        # $E000 - $EFFF
        # CPU active, Ultimax cartridge
        let p22 = i5 and i6 and i7 and not i10 and i12 and not i13

        #
        # $3000 - $3FFF, $7000 - $7FFF, $B000 - $BFFF, or $E000 - $EFFF
        # VIC active, Ultimax cartridge
        let p23 = i14 and i15 and i10 and i12 and not i13

        #
        # $1000 - $1FFF or $3000 - $3FFF
        # Ultimax cartridge
        let p24 = not i5 and not i6 and i8 and i12 and not i13

        #
        # $2000 - $3FFF
        # Ultimax cartridge
        let p25 = not i5 and not i6 and i7 and i12 and not i13

        #
        # $4000 - $7FFF
        # Ultimax cartridge
        let p26 = not i5 and i6 and i12 and not i13

        #
        # $A000 - $BFFF
        # Ultimax cartridge
        let p27 = i5 and not i6 and i7 and i12 and not i13

        #
        # $C000 - $CFFF
        # Ultimax cartridge
        let p28 = i5 and i6 and not i7 and not i8 and i12 and not i13

        # Unused.
        # let p29 = not i1

        # CAS deselected
        #
        #
        let p30 = i0

        # CAS selected
        # $D000 - $DFFF
        # CPU access, Write
        let p31 = not i0 and i5 and i6 and not i7 and i8 and not i10 and not i11

        # This is the sum-term (S-term) portion of the logic, where the P-terms calculated
        # above are logically ORed to produce a single output. This is much simpler than
        # P-term production because the P-terms handle everything about chip selection,
        # except that each chip may be the choice of several different P-terms. That's the
        # role of the S-term logic, to combine P-terms to come up with single outputs.

        # Selects BASIC ROM.
        let s1 = p0

        # Selects KERNAL ROM.
        let s2 = p1 or p2

        # Selects Character ROM.
        let s3 = p3 or p4 or p5 or p6 or p7

        # Selects I/O, color RAM, or processor registers.
        let s4 = p9 or p10 or p11 or p12 or p13 or p14 or p15 or p16 or p17 or p18

        # Selects low cartridge ROM.
        let s5 = p19 or p20

        # Selects high cartridge ROM.
        let s6 = p21 or p22 or p23

        # Selects write mode for color RAM.
        let s7 = p31

        # Deselects RAM. This is the only *de*selection, which is why it is the only one not
        # inverted in the level assignment below.
        let s0 = s1 or s2 or s3 or s4 or s5 or s6 or p24 or p25 or p26 or p27 or p28 or p30

        if s0: set(pins[F0]) else: clear(pins[F0])
        if s1: clear(pins[F1]) else: set(pins[F1])
        if s2: clear(pins[F2]) else: set(pins[F2])
        if s3: clear(pins[F3]) else: set(pins[F3])
        if s7: clear(pins[F4]) else: set(pins[F4])
        if s4: clear(pins[F5]) else: set(pins[F5])
        if s5: clear(pins[F6]) else: set(pins[F6])
        if s6: clear(pins[F7]) else: set(pins[F7])

    add_listener(pins[OE], one_listener)
    for i in 0..15: add_listener(pins[&"I{i}"], one_listener)
